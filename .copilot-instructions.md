# GitHub Copilot Instructions for WebAPI Project

## Project Overview
You are working on a **Clean Architecture ASP.NET Core 9 Web API** project that follows Domain Driven Design (DDD) principles with CQRS implementation using MediatR. The project is structured in four main layers: Domain, Application, Infrastructure, and API.

## Architecture Guidelines

### 1. Domain Layer (`WebAPI.Domain`)
- **Purpose**: Contains business entities, value objects, domain events, and core business rules
- **Key Principles**:
  - No dependencies on other layers
  - Rich domain models with encapsulated business logic
  - Use value objects for complex types (e.g., Money)
  - Implement domain events for cross-aggregate communication
  - Follow aggregate root patterns

**When working with entities:**
- Always use private constructors for Entity Framework
- Implement domain events in business methods
- Use descriptive method names that reflect business operations
- Encapsulate business rules within the entity

**Example entity method:**
```csharp
public void UpdateStock(int newStock)
{
    var oldStock = Stock;
    Stock = newStock;
    UpdatedAt = DateTime.UtcNow;
    
    AddDomainEvent(new ProductStockUpdatedEvent(this, oldStock, newStock));
}
```

### 2. Application Layer (`WebAPI.Application`)
- **Purpose**: Contains application logic, CQRS implementation, DTOs, and coordinated workflows
- **Key Principles**:
  - Use CQRS pattern with MediatR
  - Implement command and query handlers
  - Use FluentValidation for input validation
  - Return Result<T> pattern for consistent responses
  - Use DTOs for data transfer

**Command Structure:**
```csharp
[RequiresTransaction] // For complex business operations
public class CreateProductCommand : IRequest<Result<ProductDto>>, ITransactionalCommand
{
    // Properties with validation attributes
}

public class CreateProductCommandHandler : IRequestHandler<CreateProductCommand, Result<ProductDto>>
{
    // Implementation with repository patterns
}
```

**Query Structure:**
```csharp
public class GetProductByIdQuery : IRequest<Result<ProductDto?>>
{
    public int Id { get; set; }
}

public class GetProductByIdQueryHandler : IRequestHandler<GetProductByIdQuery, Result<ProductDto?>>
{
    // Use AsNoTracking() for read operations
}
```

### 3. Infrastructure Layer (`WebAPI.Infrastructure`)
- **Purpose**: Contains data access, repository implementations, and external service integrations
- **Key Principles**:
  - Implement repository interfaces from Domain layer
  - Use Entity Framework Core with Fluent API configurations
  - Implement Unit of Work pattern
  - Use performance optimizations (AsNoTracking, AsSplitQuery)
  - Handle database transactions

**Repository Implementation:**
```csharp
public class ProductRepository : Repository<Product>, IProductRepository
{
    public async Task<Product?> GetWithCategoryAsync(int id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(p => p.Category)
            .FirstOrDefaultAsync(p => p.Id == id, cancellationToken);
    }
}
```

**Entity Configuration:**
```csharp
public class ProductConfiguration : IEntityTypeConfiguration<Product>
{
    public void Configure(EntityTypeBuilder<Product> builder)
    {
        // Use Fluent API for entity configuration
        builder.OwnsOne(p => p.Price, money => 
        {
            money.Property(m => m.Amount).HasColumnName("Price");
            money.Property(m => m.Currency).HasColumnName("Currency");
        });
    }
}
```

### 4. API Layer (`WebAPI.API`)
- **Purpose**: Contains web API endpoints, middleware, and presentation logic
- **Key Principles**:
  - Use Minimal APIs for lightweight endpoints
  - Implement proper OpenAPI documentation
  - Use Options pattern for configuration
  - Handle cross-cutting concerns (CORS, validation, logging)

**Minimal API Endpoint:**
```csharp
group.MapPost("/", async (IMediator mediator, [FromBody] CreateProductDto request) =>
{
    var command = new CreateProductCommand { /* map properties */ };
    var result = await mediator.Send(command);
    
    return result.IsSuccess 
        ? Results.Created($"/api/products/{result.Data?.Id}", result)
        : Results.BadRequest(result);
})
.WithName("CreateProduct")
.WithSummary("Create a new product")
.Produces<Result<ProductDto>>(201)
.Produces<Result<ProductDto>>(400);
```

## Coding Standards and Best Practices

### SOLID Principles
1. **Single Responsibility**: Each class has one reason to change
2. **Open/Closed**: Open for extension, closed for modification
3. **Liskov Substitution**: Derived classes must be substitutable for base classes
4. **Interface Segregation**: Clients shouldn't depend on interfaces they don't use
5. **Dependency Inversion**: Depend on abstractions, not concretions

### Performance Guidelines
- Use `AsNoTracking()` for read-only queries
- Implement `AsSplitQuery()` for complex joins
- Leverage `IQueryable` for deferred execution
- Use `CancellationToken` in all async methods
- Implement query filters for global conditions (soft deletes)

### Error Handling
- Use Result<T> pattern for consistent error handling
- Centralize error messages in MessageConstants
- Implement validation using FluentValidation
- Use domain exceptions for business rule violations

### Transaction Management
- Use `[RequiresTransaction]` attribute for commands that need transactions
- Implement `ITransactionalCommand` interface for complex operations
- Use Unit of Work pattern for coordinating multiple repository operations

### Testing Guidelines
- Write unit tests for domain logic
- Use integration tests for API endpoints
- Mock external dependencies
- Test both success and failure scenarios

## Common Patterns and Examples

### Adding a New Feature (e.g., Category management)

1. **Domain Layer**:
   ```csharp
   // Add Category entity with business logic
   // Add category-related domain events
   // Add ICategoryRepository interface
   ```

2. **Application Layer**:
   ```csharp
   // Add CategoryDto classes
   // Add CreateCategoryCommand and handler
   // Add GetCategoryByIdQuery and handler
   // Add validation rules
   ```

3. **Infrastructure Layer**:
   ```csharp
   // Add CategoryConfiguration for EF Core
   // Implement CategoryRepository
   // Register in DependencyInjection
   ```

4. **API Layer**:
   ```csharp
   // Add CategoryEndpoints with minimal APIs
   // Map endpoints in Program.cs
   ```

### Message Constants Usage
Always use MessageConstants for user-facing messages:
```csharp
return Result<ProductDto>.Success(productDto, MessageConstants.ProductCreated);
return Result<ProductDto>.Failure(MessageConstants.ProductNotFound);
```

### Configuration Management
Use Options pattern for all configuration:
```csharp
builder.Services.Configure<ApiSettings>(
    builder.Configuration.GetSection(ApiSettings.SectionName));
```

## Development Workflow

1. **Start with Domain**: Define entities, value objects, and business rules
2. **Application Layer**: Create commands/queries and their handlers
3. **Infrastructure**: Implement data access and repository patterns
4. **API Layer**: Create endpoints and wire everything together
5. **Testing**: Write comprehensive tests for each layer

## Remember
- Always follow the dependency rule: inner layers don't depend on outer layers
- Use dependency injection for all cross-layer communications
- Keep controllers/endpoints thin - business logic belongs in the application layer
- Use async/await consistently throughout the application
- Implement proper logging at all layers (when required)
- Follow RESTful API conventions for endpoint design

This project template emphasizes maintainability, testability, and scalability through proper separation of concerns and established architectural patterns.